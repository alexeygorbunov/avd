<!--
  ~ Copyright (c) 2023-2024 Arista Networks, Inc.
  ~ Use of this source code is governed by the Apache License 2.0
  ~ that can be found in the LICENSE file.
  -->

# Custom Structured Configuration

With Custom Structured Configuration the user can override built-in `eos_designs` functionality or add extra knobs to be picked up by `eos_cli_config_gen` role.
There are multiple ways of supplying Custom Structured Configuration and they can all be combined.

## Variables Precedence

***TL;DR:*** eos_cli_config_gen variables in the input files will be overwritten
by the eos_designs generated facts when the role produces a value for the same
key, use custom_structured_configuration to make sure the values make it in the intended configurations._

### Overview

AVD `eos_designs` role flow is expected to work as follow:

1. from the input variables (inventory, group_vars, host_vars, ...) the `eos_designs` role generates the "structured_config"
2. The "structured_config" is used as input to the `eos_cli_config_gen` role to generate the intended EOS configuration.

A caveat is that in the inventory, group_vars, host_vars,... you can define some variables that are
used by `eos_designs` and others that are used by `eos_cli_config_gen` roles. And while it is perfectly acceptable,
the behavior can sometimes be confusing. If the key name for an `eos_cli_config_gen` variable in the variable files is the same as one of
the key name of a variable generated by `eos_designs` steps, only the value from `eos_designs` step will be configured.
However if there is no clash, then the value of the variable will be the one defined in the variable files.

The consequence is that upgrading AVD to a newer version for instance, or configuring additional `eos_designs` functionality in an existing AVD project,
could lead to additional variable keys being generated by `eos_designs` in the structured_config, overwriting previously working `eos_cli_config_gen` keys.

<!-- ![Figure 1: Variables Precedence between roles](../../../media/variables_precedence.png) -->

<div style="text-align:center">
  <img src="../../../../media/variables_precedence.png" alt="Variable Precedence logical diagram"/>
</div>

The recommendation is to use `custom_structured_configuration` as described below. This configuration will be merged on top of the `eos_designs` generated variables.
There are multiple ways of supplying Custom Structured Configuration and they can all be combined.

### Examples

A good example to demonstrate the various behaviors is to use the `ip name-server` configuration as it is quite straightforward. It is configured by `name_servers` for `eos_designs` and by `ip_name_servers` for `eos_cli_config_gen`.

#### eos_designs variables only

```yaml
---
# Only eos_designs name_servers variables
name_servers:
  - 192.168.42.10
  - 192.168.42.40
```

will generate as intended config:

```eos
ip name-server vrf MGMT 192.168.42.10
ip name-server vrf MGMT 192.168.42.40
```

#### eos_cli_config_gen variables ONLY

```yaml
---
# Only ip_name_servers from eos_ci_config_gen.
# The variables will make it to the intended config
ip_name_servers:
  - ip_address: 1.1.1.1
    vrf: EOS_CLI
  - ip_address: 192.168.42.10
    vrf: EOS_CLI
```

will generate as intended config:

```eos
ip name-server vrf EOS_CLI 1.1.1.1
ip name-server vrf EOS_CLI 192.168.42.10
```

#### eos_cli_config_gen variables and eos_designs variables

```yaml
# Both name_servers from eos_designs and ip_name_servers from
# eos_ci_config_gen. The second ones WON'T be displayed
# as they are overwritten by the generated structured_configuration
name_servers:
  - 192.168.42.10
  - 192.168.42.40

ip_name_servers:
  - ip_address: 1.1.1.1
    vrf: EOS_CLI
  - ip_address: 192.168.42.10
    vrf: EOS_CLI
```

will generate as intended config:

```eos
ip name-server vrf MGMT 192.168.42.10
ip name-server vrf MGMT 192.168.42.40
```

#### eos_designs variables and custom_structured_configuration when primary_key is not used

```yaml
---
# Both name_servers from eos_designs and ip_name_servers from
# custom_structured_configuration will make it to the intended config
name_servers:
  - 192.168.42.10
  - 192.168.42.40

custom_structured_configuration_ip_name_servers:
  - ip_address: 1.1.1.1
    vrf: EOS_CLI
  - ip_address: 192.168.42.10
    vrf: EOS_CLI
```

will generate as intended config:

```eos
ip name-server vrf EOS_CLI 1.1.1.1
ip name-server vrf MGMT 192.168.42.10
ip name-server vrf EOS_CLI 192.168.42.10
ip name-server vrf MGMT 192.168.42.40
```

Due to the default `custom_structured_configuration_list_merge` behavior (`append_rp`) and the fact that `custom_structured_configuration_ip_name_servers`'s items don't have primary key defined - resulting CLI configuration is a merge/concatenation of the two lists.

#### eos_designs variables with custom_structured_configuration when primary_key is used

To understand default behavior in case `eos_designs` is used together with `eos_cli_config_gen` data with `primary_key` set in the data schema - let's review the following example which uses `eos_designs`'s `ipv4_acls` and `eos_cli_config_gen`'s `ip_access_lists`:

```yaml
---
custom_structured_configuration_prefix:
  - 'csc_1_'
  - 'csc_2_'

ipv4_acls:  # primary_key: name
  - name: acl_1  # Collides with csc_1_acl_1
    entries:
      - remark: eos_designs_acl_1
  - name: acl_2  # Collides with csc_2_acl_2
    entries:
      - remark: eos_designs_acl_2
  - name: acl_3  # Collides with both csc_1_acl_1 and csc_2_acl_2
    entries:
      - remark: eos_designs_acl_3
  - name: acl_4  # No collisions
    entries:
      - remark: eos_designs_acl_4

csc_1_ip_access_lists:
- name: acl_1
  entries:
  - remark: csc_1_acl_1
- name: acl_3
  entries:
  - remark: csc_1_acl_3
- name: acl_11
  entries:
  - remark: csc_1_acl_11

csc_2_ip_access_lists:
- name: acl_2
  entries:
  - remark: csc_2_acl_2
- name: acl_3
  entries:
  - remark: csc_2_acl_3
- name: acl_12
  entries:
  - remark: csc_2_acl_12
```

This input data will generate the following intended config:

```eos
ip access-list acl_1
   remark eos_designs_acl_1
   remark csc_1_acl_1
!
ip access-list acl_2
   remark eos_designs_acl_2
   remark csc_2_acl_2
!
ip access-list acl_3
   remark eos_designs_acl_3
   remark csc_1_acl_3
   remark csc_2_acl_3
!
ip access-list acl_4
   remark eos_designs_acl_4
!
ip access-list acl_11
   remark csc_1_acl_11
!
ip access-list acl_12
   remark csc_2_acl_12
```

Important things to note:

- Rendered CLI configuration has only one `acl_1`. Although `acl_1` was defined by both `ipv4_acls` and `csc_1_ip_access_lists` - both dictionaries are merged/updated due to the same value of the primary key `name`. Same is applicable to ACLs `acl_2` (defined by `ipv4_acls` and `csc_2_ip_access_lists`) and `acl_3` (defined by `ipv4_acls` and both `csc_1_ip_access_lists` and `csc_2_ip_access_lists`).
- ACLs merged/updated from multiple data sources (like `acl_1`, `acl_2` and `acl_3`) concatenate ACEs (`remark` statements) from all sources. This is due to the fact that data model for individual ACEs has no primary key defined. Therefore all ACEs are concatenated together under the same parent ACL.
- ACLs `acl_4` (from `ipv4_acls`), `acl_11` (from `csc_1_ip_access_lists`) and `acl_12` (from `csc_2_ip_access_lists`) all made their way to the intended config in the original format due to the fact that their names (primary keys) were unique across all three data sources.

## `structured_config` in `eos_designs` data models

This feature enables the user to supply `structured_config` on various levels in the `eos_designs` data model.

### Connected Endpoints

All relevant `structured_config` sections will be merged.

```yaml
< connected_endpoints_keys.key >:
  < endpoint_1 >:
    adapters:
      - <...>
        # Custom structured config added under ethernet_interfaces.<interface> for eos_cli_config_gen
        structured_config: < dictionary >
        port_channel:
          # Custom structured config added under port_channel_interfaces.<interface> for eos_cli_config_gen
          structured_config: < dictionary >
```

See [Connected Endpoints]('connected-endpoints.md')

### Fabric Topology

Only the most specific `structured_config` key will be used

```yaml
< node_type_key >:
  defaults:
    # Custom structured config for eos_cli_config_gen
    structured_config: < dictionary >
  nodes:
    < node >:
      # Custom structured config for eos_cli_config_gen
      structured_config: < dictionary >
  node_groups:
    < node_group >:
      # Custom structured config for eos_cli_config_gen
      structured_config: < dictionary >
      nodes:
        < node >:
          # Custom structured config for eos_cli_config_gen
          # Overrides the setting on node_group level.
          structured_config: < dictionary >
```

See [Fabric Topology]('fabric-topology.md')

### Network Services (a.k.a. "tenants")

All relevant `structured_config` sections will be merged. Note that setting `structured_config` under `svi.nodes` will override the setting on `svi`.

```yaml
tenants:
  vrfs:
    < vrf >:
      # Custom structured config for eos_cli_config_gen
      structured_config: < dictionary >
      bgp:
        # Custom structured config added under router_bgp.vrfs.<vrf> for eos_cli_config_gen
        structured_config: < dictionary >
      svis:
        < vlan >:
          # Custom structured config added under vlan_interfaces.<interface> for eos_cli_config_gen
          structured_config: < dictionary >
          nodes:
            < node >:
              # Custom structured config added under vlan_interfaces.<interface> for eos_cli_config_gen
              # Overrides the setting on SVI level.
              structured_config: < dictionary >
```

See [Network Services]('network-services.md')

All `structured_config` knobs honor the `list_merge` strategy set in `custom_structured_configuration_list_merge` described in the next section.

## `custom_structured_configuration`

Custom EOS Structured Configuration keys can be set on any group or host_var level using the name
of the corresponding `eos_cli_config_gen` key prefixed with content of `custom_structured_configuration_prefix`.
The content of Custom Structured Configuration variables will be combined with the structured config generated by the eos_designs role.
By default Lists are merged/concatenated and Dictionaries are updated. The combine is done recursively, so it is possible to update a sub-key of a variable set by
`eos_designs` role already.
The List-merge strategy can be changed using `custom_structured_configuration_list_merge`. Since most data models move towards lists and
input data is auto-converted from dicts to lists, it is more likely that `custom_structured_configuration_list_merge: replace` will
overwrite list data unintentionally. So going forward `replace` should be avoided.

### Variables and Options

--8<--
roles/eos_designs/docs/tables/custom-structured-configuration.md
--8<--

### Examples

#### Example using default prefix

```yaml
custom_structured_configuration_ip_name_servers:
  - ip_address: 10.2.3.4
    vrf: MGMT
custom_structured_configuration_ethernet_interfaces:
  - name: Ethernet4000
    description: My test
    ip_address: 10.1.2.3/12
    shutdown: false
    type: routed
    mtu: 1500
    peer: MY-own-peer
    peer_interface: Ethernet123
    peer_type: my_precious
```

In this example the contents of the `ip_name_servers` variable in the Structured Configuration will be concatenated with the list `[ 10.2.3.4 ]`
and `Ethernet4000` will be added to the `ethernet_interfaces` dictionary (in case item with `name: Ethernet4000` is not yet defined, otherwise existing item will be updated) in the Structured Configuration.

`custom_structured_configuration_prefix` allows the user to customize the prefix for Custom Structured Configuration variables.
Default value is `custom_structured_configuration_`. Remember to include any delimiter like the last `_` in this case.
It is possible to specify a list of prefixes, which will all be merged one by one. The order of merge will start from beginning of the list, which means that keys defined in the later prefixes will be able to override keys defined in previous ones.

#### Example using multiple prefixes

```yaml
custom_structured_configuration_prefix: [ my_dci_ , my_special_dci_ ]

my_dci_ethernet_interfaces:
  - name: Ethernet4000
    description: My test
    ip_address: 10.1.2.3/12
    shutdown: false
    type: routed
    mtu: 1500
    peer: MY-own-peer
    peer_interface: Ethernet123
    peer_type: my_precious

my_special_dci_ethernet_interfaces:
  - name: Ethernet4000
    ip_address: 10.3.2.1/21
```

In this example `Ethernet4000` will be added to the `ethernet_interfaces` list in the Structured Configuration and the ip_address will be `10.3.2.1/21` since ip_adddress was overridden on the later `custom_structured_configuration_prefix`
